Pipelined Silver processor: bugs found during the verification work.

1. SHIFT instruction, func and visible carry/overflow flags.
Usually, func (Bit9-6) is used by the ALU to check which function to apply.
SHIFT instructions use Bit7-6 as the input, ie the lower 2 bits of func.
When designing the pipelined machine, to save resources and avoid unnecessary variables, the processor applies the func for both ALU and SHIFT.
But this will create a violation for the ISA.
Suppose there is a SHIFT instr where func:0000, 
although the shift result is correct, 
the ALU is also updated where the visible registers carry/overflow flags can be changed which will not happen on the ISA level.

This problem is hard to find by testing, since it requires special test programs that contain SHIFT -> ALU(take carry/overflow flags). 
For example, with the test programs from CakeML, we did not find this bug. 

The previous Silver processor does not have this bug, since it assigns func to 9 when shift and uses Bit7-6 directly when computing shift.
But the pipeline design cannot do so, because ALU and shift are computed in the EX stage where the instruction(32bits) is already decoded.

Solution: when checking SHIFT, assign 11[BIT7-6] as the func, so the flags cannot be changed (requires func as 0 or 1).
We do not create a new variable like SHIFT_func to save hardware resources.
https://github.com/kth-step/hw-verification-silver/commit/859b2b2c5d10c7c02ca26bd5b7008756c392ad89

2. introduce the option for scheduling function I
In order to handle the case when jump is in the fetch or decode stage that cannot be recognized by the pipeline (as the EX stage takes care of jump).

If the fetch or decode stage I is NONE, then we do not need to compare the value with ISA state, since these instrs are not going to be executed in the end.

3. Why do we identify the jump in the EX stage, not the ID stage?
Since we need the ALU to compute the jump target for Jump and condition result for conditional jumps.
TO remember: check similar ISAs like Silver that require the computations from stages later than ID (i.e., jumps cannot be issued from the ID stage).
Example: RISV-V RV32I (instr:JALR). ARMv8-A (B.<cond> <label>).

4. Move the Acc from EX to the MEM stage.
EX stage only handles ALU and shift computations, and MEM can handle the instructions that require the response from the external components, like memory and accelerator.
